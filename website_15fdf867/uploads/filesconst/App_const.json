{

"MemDFM_DMForAll":"
 object DM: TDM
  OnCreate = DataModuleCreate
  OnDestroy = DataModuleDestroy
  Height = 436
  Width = 538
  object FDGUIxWaitCursor1: TFDGUIxWaitCursor
    Provider = 'FMX'
    Left = 96
    Top = 280
  end
  object RTLFixer1: TRTLFixer
    ArabicDigits = True
    DigitTypes = ArabicDigitType1
    MathOrder = LeftToRight
    Options = []
    Left = 395
    Top = 168
  end
  object GS: TGS
    Left = 304
    Top = 181
  end
  object UniConnection: TUniConnection
    ProviderName = 'SQLite'
    SpecificOptions.Strings = ('SQLite.Direct=True')
    LoginPrompt = False
    Left = 384
    Top = 264
  end
  object MySQLUniProvider1: TMySQLUniProvider
    Left = 224
    Top = 200
  end
  object SQLiteUniProvider1: TSQLiteUniProvider
    Left = 304
    Top = 328
  end
  object SQLServerUniProvider1: TSQLServerUniProvider
    Left = 160
    Top = 360
  end
end
",
"MemUnit_DMForAll":" 
unit DmUnit;

interface

uses
  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,
  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,
  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.FMXUI.Wait,
  FireDAC.Stan.ExprFuncs, FireDAC.Phys.SQLiteDef, FireDAC.Phys.SQLite, Data.DB,
  FireDAC.Comp.Client, FMX.Forms, Controllers,
  //// FireDAC.VCLUI.Wait,
{$IFDEF ANDROID}
  FMX.Dialogs,
{$ENDIF}
{$IFDEF MSWINDOWS}
  FMX.Dialogs,
{$ENDIF}
  FMX.Types, FMX.Controls,   IOUtils,
  FireDAC.Comp.UI, FireDAC.Stan.Param, FireDAC.DatS,
  FireDAC.DApt.Intf, FireDAC.DApt, FireDAC.Comp.DataSet, inifiles,
  System.ImageList, FMX.ImgList, RTL.Controls, GSUnit, SQLServerUniProvider,
  SQLiteUniProvider, UniProvider, MySQLUniProvider, DBAccess, Uni;

type

  TDM = class(TDataModule)
    FDGUIxWaitCursor1: TFDGUIxWaitCursor;
    RTLFixer1: TRTLFixer;
    GS: TGS;
    UniConnection: TUniConnection;
    MySQLUniProvider1: TMySQLUniProvider;
    SQLiteUniProvider1: TSQLiteUniProvider;
    SQLServerUniProvider1: TSQLServerUniProvider;
    procedure DataModuleCreate(Sender: TObject);
    procedure DataModuleDestroy(Sender: TObject);

  private
    FDBCtrl: TDBController;
    { Private declarations }

    function GetDBCtrl: TDBController;

  public
    property DBCtrl: TDBController read GetDBCtrl write FDBCtrl;
    { Public declarations }
    function GetAuth(aStr: string): Boolean;
    function NewQuery: TUniQuery;
    function Login(aUsername, aPassword: string): Boolean;
    procedure AlertMessage;
    procedure FreeObjectCB(aItems: Tstrings);
    function CheckConnection: Boolean;

  var

    IsConnect, IsActive, IsLogin: Boolean;
    ID, NameServer, PathLocal: string;
    Separator: string;

  end;

var
  DM: TDM;

implementation

{ %CLASSGROUP 'Vcl.Controls.TControl' }

uses Consts;

{$R *.dfm}
{ TDM }

procedure TDM.DataModuleCreate(Sender: TObject);
var
  IsConnected: Boolean;
begin

{$IFDEF MSWINDOWS}
  PathLocal := ExtractFilePath(ParamStr(0));
  //// FDPhysMySQLDriverLink1.VendorLib := PathLocal + 'libmysql.dll';
{$ENDIF}
{$IF DEFINED(IOS) or DEFINED(ANDROID)}
  PathLocal := TPath.GetDocumentsPath + PathDelim;
{$ENDIF}
  //// UniConnection.Database := PathLocal + 'DB.db';

end;

procedure TDM.DataModuleDestroy(Sender: TObject);
begin
  FDBCtrl.Free;
end;

procedure TDM.FreeObjectCB(aItems: Tstrings);
begin
  GS.FreeItems(aItems);
end;

procedure TDM.AlertMessage;
begin
  ShowMessage(MSG_SAVE_DONE);

{$IFDEF MSWINDOWS}
{$ENDIF}
{$IF DEFINED(IOS) or DEFINED(ANDROID)}
{$ENDIF}
end;

function TDM.GetAuth(aStr: string): Boolean;
begin
  { Result := True;
    Exit;
    with TUser.Create(ID) do
    try
    with TRole.Create(Role_id) do
    try
    Result := GS.IsStringInListString(aStr, Auth);
    if not Result then
    ShowMessage(NOT_AUTH);
    finally
    Free;
    end;
    finally
    Free;
    end; }
end;

function TDM.GetDBCtrl: TDBController;
begin
  if Assigned(FDBCtrl) then
    FDBCtrl.Free;
  FDBCtrl := TDBController.Create(UniConnection);
  Result := FDBCtrl;
end;

function TDM.Login(aUsername, aPassword: string): Boolean;
var
  Qry: TUniQuery;
begin
  Result := true;
  {
    Result := false;
    Qry := dm.NewQuery;
    try
    Qry.SQL.Text := ' select ID from  Users where  Username  = :Username and  '
    + '  PassWord  = :PassWord ';
    Qry.ParamByName('Username').Value := aUsername;
    Qry.ParamByName('PassWord').Value := dm.GS.EncryptSTR(aPassword);
    Qry.Open();
    if Qry.FieldByName('ID').Asstring <> EmptyStr then
    begin
    ID := Qry.FieldByName('ID').Asstring;
    Result := True;
    end;
    finally
    Qry.Free;
    end; }
end;

function TDM.NewQuery: TUniQuery;
begin
  Result := TUniQuery.Create(Self);
  Result.Connection := UniConnection;
end;

function TDM.CheckConnection: Boolean;
begin
  Result := False;
  try
    UniConnection.Open();
    Result := UniConnection.Connected;
  except
  end;
end;

end.

 
",
"MemConstForAll":"
unit Consts;

interface

Const

  Color_Item = $FFEFECEF;
  Duration_Item = 0.5;
  Delay_Item = 0.1;

  DLG_CONFIRME_DELETE = 'Confirme Delete';
  MSG_NOTIFICTION = 'Notifiction';
  MSG_SAVE_DONE = 'Save Done';
  MSG_NOT_AUTH = 'Not Auth';
  MSG_ERROR_CONNECTION_DB = 'Error Connection To Data Base ';
  MSG_DLG_SET_CONFIG_CONNECTION_DB = ' You Want Entre Config Connection ? ';

@SQL_GET_ALL_TABLES

implementation

end.

",
 "MemControllerForAll":"  
 unit Controllers;

interface

uses
  FireDAC.Comp.Client, System.Variants, SysUtils, System.IOUtils,
  System.Classes, Data.DB, FireDAC.Comp.DataSet,
{$IFDEF MSWINDOWS}
  FireDAC.Phys.MSSQLDef,
{$ENDIF}
  IniFiles,
  FireDAC.Phys.SQLiteDef,
  System.Generics.Collections, Data.DBXJSONCommon, JSON,
  DateUtils, Math, System.Types, Uni;

type

  TDBController = class
  private
    FConn: TUniConnection;
  public
    constructor Create(aConn: TUniConnection);
    property Conn: TUniConnection read FConn write FConn;
    procedure PrepareData(aSql: string; aDataSet: TDataSet;
      aParameter: TArray < string >= []);
    procedure AlertMessage;
  end;

implementation

{ TDBController }
{$WARN IMPLICIT_STRING_CAST OFF}
{$WARN IMPLICIT_STRING_CAST_LOSS OFF}

uses DmUnit, Consts;

procedure TDBController.AlertMessage;
begin

end;

constructor TDBController.Create(aConn: TUniConnection);
begin
  FConn := aConn;
end;


procedure TDBController.PrepareData(aSql: string; aDataSet: TDataSet;
  aParameter: TArray<string>);
var
  Qry: TUniQuery;
  I, PosEqual: Integer;
  Key, Value: string;
  FieldDef: TFieldDef;
  FieldType: TFieldType;
begin
  Qry := TUniQuery.Create(FConn);
  try
    Qry.Connection := FConn;
    Qry.SQL.Text := aSql;
    for I := Low(aParameter) to High(aParameter) do
    begin
      // Key, Value
      PosEqual := Pos(*-*=*-*, aParameter[I]);
      if PosEqual > 0 then
      begin
        Key := Copy(aParameter[I], 1, PosEqual - 1);
        Value := Copy(aParameter[I], PosEqual + 1, Length(aParameter[I]) -
          PosEqual);
        Qry.ParamByName(Key).Value := Value;
      end;
    end;
    Qry.Open;

     if aDataSet.Fields.Count = 0 then
      with TFDMemTable(aDataSet) do
      begin
        for I := 0 to Qry.FieldDefs.Count - 1 do
        begin
          FieldDef := Qry.FieldDefs[I];
          FieldType := FieldDef.DataType;
          if FieldType = ftWideString then
            FieldType := ftString;
          FieldDefs.Add(FieldDef.Name, FieldType, FieldDef.Size,
            FieldDef.Required);
        end;
        CreateDataSet;
      end;

    aDataSet.ControlsDisabled;
    if aDataSet.Active = False then
      aDataSet.Open;
    with TFDMemTable(aDataSet) do
    begin
      BeginBatch;
      EmptyDataSet;
      EndBatch;
    end;
    TFDMemTable(aDataSet).CopyDataSet(Qry);
    aDataSet.EnableControls;

  finally
    Qry.Free;
  end;

end;

end.
 "   
}